/*
 * Copyright 2021 IBM Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy
 * of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */
package com.ibm.watson.litelinks.client;

import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableMap;
import com.ibm.watson.kvutils.factory.KVUtilsFactory;
import com.ibm.watson.litelinks.InvalidThriftClassException;
import com.ibm.watson.litelinks.LitelinksEnvVariableNames;
import com.ibm.watson.litelinks.LitelinksSystemPropNames;
import com.ibm.watson.litelinks.ServiceRegistryTypes;
import com.ibm.watson.litelinks.client.ServiceInstanceCache.ListenerWithExecutor;
import com.ibm.watson.litelinks.etcd.EtcdServiceRegistry;
import org.apache.thrift.TServiceClient;
import org.apache.thrift.protocol.TProtocolFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.Executor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import static com.ibm.watson.litelinks.client.TServiceClientManager.THRIFT_CLIENT_ASYNC_IFACE_NAME;
import static com.ibm.watson.litelinks.client.TServiceClientManager.THRIFT_CLIENT_IFACE_NAME;

/**
 * Used to create Litelinks thrift clients from thrift-generated bindings.
 * <p>
 * Note the builder itself is not threadsafe but the built clients are.
 *
 * @param <I> the thrift-generated client interface
 */
public final class ThriftClientBuilder<I> {

    private static final Logger logger = LoggerFactory.getLogger(ThriftClientBuilder.class);

    public static final int DEFAULT_COMMAND_TIMEOUT = 20_000; // 20 seconds in millis

    final Class<? extends I> clientClass;
    final Class<I> clientInterface;
    final Class<?> clientAsyncInterface;

    private Set<ServiceRegistryClient> serviceRegistries = new HashSet<>(4);
    private boolean includeExternalRegistryConfig;
    private String mplexerName;
    private ImmutableMap.Builder<String, String> imb;

    String serviceName;

    int timeoutMillis = DEFAULT_COMMAND_TIMEOUT; // 0 means no timeout
    I fallbackClass;

    List<ListenerWithExecutor> listeners;
    LoadBalancingPolicy lbPolicy = TServiceClientManager.DEFAULT_LB_POLICY;

    static class MethodConfig {
        int timeout = -1; //TBD or Integer
        FallbackProvider<?> fallback;
        Method syncMethod; // only used in pseudo-async case
    }

    // actually more efficient to use String rather than Method as key
    final Map<String, MethodConfig> methodConfig = new HashMap<>();

    private boolean locked;

    // used only during client construction
    private MethodConfig getOrAddMethodConfig(String methodName) {
        MethodConfig mc = methodConfig.get(methodName);
        if (mc == null) {
            methodConfig.put(methodName, mc = new MethodConfig());
        }
        return mc;
    }

    /**
     * Start building a new Litelinks client based on autogenerated thrift service interface.
     * The resulting client object will implement both the service Iface interface and the
     * {@link LitelinksServiceClient} interface.
     *
     * @param clientClass autogenerated thrift interface (Iface) <b>OR</b> client class (which extends {@link TServiceClient})
     */
    @SuppressWarnings("unchecked")
    public static <I> ThriftClientBuilder<I> newBuilder(Class<? extends I/* & TServiceClient */> clientClass) {
        if (clientClass.isInterface() && THRIFT_CLIENT_IFACE_NAME.equals(clientClass.getSimpleName())) {
            Class<?> topSvcClass = clientClass.getDeclaringClass();
            if (topSvcClass != null) {
                Class<?>[] svcClasses = topSvcClass.getDeclaredClasses();
                if (svcClasses != null) {
                    for (Class<?> sc : svcClasses) {
                        if (TServiceClient.class.isAssignableFrom(sc)) {
                            return new ThriftClientBuilder<I>((Class<? extends I>) sc);
                        }
                    }
                }
            }
        }
        return new ThriftClientBuilder<I>(clientClass);
    }

    /**
     * Start building a new generic {@link LitelinksServiceClient} which doesn't
     * require the thrift generated classes or knowledge of the service type.
     * Can be used to check general information about the service such as availability,
     * connectivity, etc.
     * <p>
     * The {@link #withServiceName(String)} method must be used to specify the logical
     * name of the target service
     */
    public static ThriftClientBuilder<LitelinksServiceClient> newBuilder() {
        return new ThriftClientBuilder<LitelinksServiceClient>();
    }

    // called only from newBuilder method
    @SuppressWarnings("unchecked")
    private ThriftClientBuilder() {
        this.clientInterface = (Class<I>) LitelinksServiceClient.class;
        this.clientAsyncInterface = null;
        this.clientClass = null;
    }

    // called only from newBuilder(clientClass) method
    @SuppressWarnings("unchecked")
    private ThriftClientBuilder(Class<? extends I> clientClass) {
        //TODO also support AsyncClient (maybe later)
        if (!TServiceClient.class.isAssignableFrom(clientClass)) {
            throw new InvalidThriftClassException("Must use thrift-generated service interface or client class");
        }
        this.clientClass = clientClass;
        for (Class<?> intf : clientClass.getInterfaces()) {
            if (THRIFT_CLIENT_IFACE_NAME.equals(intf.getSimpleName())) {
                this.clientInterface = (Class<I>) intf;
                this.clientAsyncInterface = getAsyncIface(intf);
                return;
            }
        }
        throw new InvalidThriftClassException(clientClass.getName()
            + " does not implement " + THRIFT_CLIENT_IFACE_NAME);
    }

    private static Class<?> getAsyncIface(Class<?> iface) {
        for (Class<?> c : iface.getEnclosingClass().getDeclaredClasses()) {
            if (c.isInterface() &&
                THRIFT_CLIENT_ASYNC_IFACE_NAME.equals(c.getSimpleName())) {
                return c;
            }
        }
        logger.warn(THRIFT_CLIENT_ASYNC_IFACE_NAME + " not found for " + iface);
        return null;
    }

    public I build() {
        try {
            return buildOnceAvailable(0L);
        } catch (InterruptedException | TimeoutException e) {
            throw new RuntimeException(e); // won't happen
        }
    }

    private static final Class<?>[] GENERIC_IFACE_ONLY = { LitelinksServiceClient.class };

    @SuppressWarnings("unchecked")
    <C extends TServiceClient> TServiceClientManager<C> getFreshClientPool(ServiceRegistryClient srClient) {
        final String mplexerName = getMultiplexerName();
//		final String svcName = mplexerName!=null ? mplexerName : serviceName;
        try {
            return TServiceClientManager.get(srClient, serviceName, mplexerName, (Class<C>) clientClass);
        } catch (Exception e) {
            throw asRuntimeException(e);
        }
    }

    /**
     * @param availTimeout time to block until service becomes available, or 0 to not check
     * @param unit         unit of availTimeout argument
     * @throws TimeoutException if service does not become available within specified time
     */
    public <C extends TServiceClient> I buildOnceAvailable(long availTimeout, TimeUnit unit)
            throws InterruptedException, TimeoutException {
        long millis = TimeUnit.MILLISECONDS.convert(availTimeout, unit);
        if (millis == 0 && availTimeout > 0L) {
            millis = 1;
        }
        return buildOnceAvailable(millis);
    }

    private void populateMethodConfigs() {
        if (clientClass == null || clientInterface == null) {
            return;
        }
        for (Method meth : clientInterface.getMethods()) {
            getOrAddMethodConfig(meth.getName()).syncMethod = meth;
        }
    }

    /**
     * @param availTimeoutMillis time in milliseconds to block until service becomes available, or 0 to not check
     * @throws TimeoutException if service does not become available within specified time
     */
    @SuppressWarnings("unchecked")
    public <C extends TServiceClient> I buildOnceAvailable(long availTimeoutMillis)
            throws InterruptedException, TimeoutException {
        final Map<String, String> defaultContext = imb != null ? imb.build() : null;
        final ServiceRegistryClient srClient = getServiceRegistry();
        //TODO probably add info log to list the service registries (check existing log)

        //TODO this method should probably throw checked exception
        final TServiceClientManager<C> origClientPool = getFreshClientPool(srClient);

        if (lbPolicy != TServiceClientManager.DEFAULT_LB_POLICY) {
            logger.warn("Litelinks custom loadbalancer support is alpha," +
             " subject to API-breaking change in later versions");
        }

        if (availTimeoutMillis > 0L && !origClientPool.awaitAvailable(availTimeoutMillis)) {
            throw new TimeoutException();
        }

        populateMethodConfigs();

        final Class<?>[] ifaces = clientClass == null ? GENERIC_IFACE_ONLY
                : clientAsyncInterface == null ? new Class<?>[] { clientInterface, LitelinksServiceClient.class }
                : new Class<?>[] { clientInterface, clientAsyncInterface, LitelinksServiceClient.class };
        final ClassLoader loader = clientClass == null ? ThriftClientBuilder.class.getClassLoader()
            : clientClass.getClassLoader();

        I client = (I) Proxy.newProxyInstance(loader, ifaces,
            new ClientInvocationHandler(this, defaultContext, srClient, origClientPool, ifaces, loader));
        imb = null;
        if (listeners != null) {
            origClientPool.addListeners(listeners);
        }
        locked = true;
        return client;
    }

    /*
     *
     */
    private ServiceRegistryClient getServiceRegistry() {
        Set<ServiceRegistryClient> serviceRegs = serviceRegistries;
        if (serviceRegs == null) {
            serviceRegs = new HashSet<>(4);
        }
        if (includeExternalRegistryConfig || serviceRegs.isEmpty()) {
            addExternallyConfiguredRegistries(serviceRegs);
        }
        ServiceRegistryClient regClient;
        if (!serviceRegs.isEmpty()) {
            if (serviceRegs.size() == 1) {
                regClient = serviceRegs.iterator().next();
            } else {
                regClient = new CompositeServiceRegistry(serviceRegs);
            }
        } else {
            // Defaults to ZOOKEEPER env var, then KV_STORE env var, else fail
            // (prior behaviour was to lastly default to static localhost:1081)
            regClient = ZookeeperServiceRegistry.getDefault();
            if (regClient == null) {
                String kvStore = System.getProperty(KVUtilsFactory.KV_STORE_EV);
                if (kvStore == null) {
                    kvStore = System.getenv(KVUtilsFactory.KV_STORE_EV);
                }
                if (kvStore != null) {
                    regClient = registryFromTargetString(kvStore);
                } else {
                    throw new IllegalStateException(
                            "No registry configured for litelinks service client"
                            + (serviceName != null ? " " + serviceName : "") + ", set "
                            + LitelinksEnvVariableNames.CLIENT_DISCOVERY + " env var");
                }
            }
        }
        serviceRegistries = null;
        return regClient;
    }

    //TODO memoize this
    private static void addExternallyConfiguredRegistries(Set<ServiceRegistryClient> set) {
        String sysProp = System.getProperty(LitelinksSystemPropNames.CLIENT_REGISTRIES);
        if (sysProp != null) {
            for (String srString : sysProp.split("\\|")) {
                set.add(registryFromTargetString(srString));
            }
        } else {
            String envVar = System.getenv(LitelinksEnvVariableNames.CLIENT_DISCOVERY);
            if (envVar != null) {
                for (String srString : envVar.split("\\|")) {
                    set.add(registryFromTargetString(srString));
                }
            } else {
                sysProp = System.getProperty(LitelinksSystemPropNames.SERVER_REGISTRY);
                if (sysProp != null) {
                    set.add(registryFromTargetString(sysProp));
                } else {
                    envVar = System.getenv(LitelinksEnvVariableNames.SERVER_REGISTRY);
                    if (envVar != null) {
                        set.add(registryFromTargetString(envVar));
                    }
                }
            }
        }
    }

    private static ServiceRegistryClient registryFromTargetString(String targetString) {
        int delim = targetString.indexOf(':');
        if (delim < 0) {
            throw new IllegalArgumentException("invalid service registry string: " + targetString);
        }
        String type = targetString.substring(0, delim), connString = targetString.substring(delim + 1);
        switch (type) {
        case ServiceRegistryTypes.ETCD:
            try {
                return new EtcdServiceRegistry(connString);
            } catch (IOException ioe) {
                throw new RuntimeException("error reading etcd config file: " + connString, ioe);
            }
        case ServiceRegistryTypes.ZOOKEEPER:
            return new ZookeeperServiceRegistry(connString);
        case ServiceRegistryTypes.STATIC:
            return new StaticServiceRegistry(connString);
        default:
            throw new IllegalArgumentException("unrecognized service registry type: " + type);
        }
    }

    private String getMultiplexerName() {
        String mplexer = mplexerName;
        if (mplexer == null) {
            mplexer = System.getenv(LitelinksEnvVariableNames.MULTIPLEXER);
        }
        return mplexer;
    }

    private ThriftClientBuilder<I> addServiceRegistry(ServiceRegistryClient serviceReg) {
        checkModificationOk();
        serviceRegistries.add(serviceReg);
        return this;
    }

    // builder methods

    /**
     * The zookeeper connection string to use for service discovery
     *
     * @param connString
     */
    public ThriftClientBuilder<I> withZookeeper(String connString) {
        return addServiceRegistry(new ZookeeperServiceRegistry(connString));
    }

    /**
     * A static server to use instead of dynamic service discovery
     *
     * @param hostname
     * @param port
     */
    public ThriftClientBuilder<I> withStaticServer(String hostname, int port) {
        return addServiceRegistry(new StaticServiceRegistry(hostname, port));
    }

    /**
     * A static server to use instead of dynamic service discovery
     *
     * @param hostname
     * @param port
     * @param ssl
     */
    public ThriftClientBuilder<I> withStaticServer(String hostname, int port, boolean ssl) {
        return addServiceRegistry(new StaticServiceRegistry(hostname, port, null, null, ssl, null));
    }

    /**
     * A static server to use instead of dynamic service discovery
     *
     * @param hostname
     * @param port
     * @param protoFactory
     * @param framed
     * @param ssl
     */
    public ThriftClientBuilder<I> withStaticServer(String hostname, int port,
            Class<? extends TProtocolFactory> protoFactory, boolean framed, boolean ssl) {
        return addServiceRegistry(new StaticServiceRegistry(hostname, port,
                protoFactory, framed, ssl, null));
    }

    /**
     * A static server to use instead of dynamic service discovery
     *
     * @param hostname
     * @param port
     * @param protoFactory
     * @param framed
     * @param ssl
     * @param extraInfoSupported
     */
    public ThriftClientBuilder<I> withStaticServer(String hostname, int port,
            Class<? extends TProtocolFactory> protoFactory,
            boolean framed, boolean ssl, boolean extraInfoSupported) {
        return addServiceRegistry(new StaticServiceRegistry(hostname, port,
                protoFactory, framed, ssl, extraInfoSupported));
    }

    /**
     * This method can be chained to provide multiple registries
     *
     * @param targetString string of the form "type:conn-string"
     * @return
     */
    public ThriftClientBuilder<I> withServiceRegistry(String targetString) {
        return addServiceRegistry(registryFromTargetString(targetString));
    }

    /**
     * Not required if no other service registries are provided
     */
    public void includeExternallyConfiguredRegistries() {
        includeExternalRegistryConfig = true;
    }

    /**
     * Logical service name. Uniquely defines a cluster (aka resource group);
     * used for discovery
     *
     * @param name
     */
    public ThriftClientBuilder<I> withServiceName(String name) {
        checkModificationOk();
        serviceName = name;
        return this;
    }

    /**
     * Default timeout for all methods
     *
     * @param millis time in milliseconds, or 0 to disable client-level timeout
     */
    public ThriftClientBuilder<I> withTimeout(int millis) {
        checkModificationOk();
        timeoutMillis = millis;
        return this;
    }

    /**
     * Default timeout for all methods
     *
     * @param duration the duration
     * @param unit     the unit of the duration
     */
    public ThriftClientBuilder<I> withTimeout(long duration, TimeUnit unit) {
        int timeout = (int) TimeUnit.MILLISECONDS.convert(duration, unit);
        return withTimeout(timeout > 0 ? timeout : 1);
    }

    /**
     * Timeout for a specific method
     *
     * @param method the name of the method
     * @param millis time in milliseconds
     */
    public ThriftClientBuilder<I> withTimeout(String method, int millis) {
        checkModificationOk();
        if (millis < 0) {
            throw new IllegalArgumentException("negative timeout");
        }
        getMethod(method); // this checks method name is valid
        getOrAddMethodConfig(method).timeout = millis;
        return this;
    }

    /**
     * Timeout for a specific method
     *
     * @param method   the name of the method
     * @param duration the duration
     * @param unit     the unit of the duration
     */
    public ThriftClientBuilder<I> withTimeout(String method, long duration, TimeUnit unit) {
        return withTimeout(method, (int) TimeUnit.MILLISECONDS.convert(duration, unit));
    }

    /**
     * Interface implementation used to provide fallback values for
     * all methods. Will overwrite any <b>prior</b> per-method fallbacks specified.
     *
     * @param fallbackClass
     */
    public ThriftClientBuilder<I> withFallback(I fallbackClass) {
        checkModificationOk();
        this.fallbackClass = fallbackClass;
        for (MethodConfig mc : methodConfig.values()) {
            mc.fallback = null;
        }
        return this;
    }

    /**
     * FallbackProvider for a specific method. Takes precedence over <b>prior</b>
     * specified interface impl fallbacks
     *
     * @param method the name of the method
     * @param fp     the {@link FallbackProvider} implementation
     */
    public ThriftClientBuilder<I> withFallback(String method, FallbackProvider<?> fp) {
        checkModificationOk();
        getMethod(method); // this checks method name is valid
        getOrAddMethodConfig(method).fallback = fp;
        return this;
    }

//	/**
//	 *
//	 * @param concConnsCap max concurrent in-flight method invocations
//	 *     or 0 for unlimited
//	 */
//	public ThriftClientBuilder<I> withMaxConnections(int concConnsCap) {
//		checkModificationOk();
//		if(concConnsCap < 0) throw new IllegalArgumentException();
//		sem = concConnsCap == 0 ? null : new Semaphore(concConnsCap, true);
//		return this;
//	}

    /**
     * Specify name of mutliplexer service. The name provided is used for initial
     * service discovery, and the service name passed to the
     * {@link #withServiceName(String)} method is considered to be
     * the <b>multiplexed service</b>'s name.
     */
    public ThriftClientBuilder<I> withMultiplexer(String serviceName) {
        checkModificationOk();
        mplexerName = serviceName;
        return this;
    }

    /**
     * Provide a map of key/value pairs which will be propagated to
     * services from this client. Will be merged with any params
     * provided via {@link #withContextEntry(String, String)}
     *
     * @param contextParams
     */
    public ThriftClientBuilder<I> withContext(Map<String, String> contextParams) {
        checkModificationOk();
        if (imb == null) {
            imb = new ImmutableMap.Builder<>();
        }
        imb.putAll(contextParams);
        return this;
    }

    /**
     * Add the specified key/value pair to this client's default context map.
     * The same key can't be added more than once. Will be merged with any
     * params provided via {@link #withContext(Map)}
     *
     * @param key
     * @param value
     */
    public ThriftClientBuilder<I> withContextEntry(String key, String value) {
        checkModificationOk();
        if (imb == null) {
            imb = new ImmutableMap.Builder<>();
        }
        imb.put(key, value);
        return this;
    }

    /**
     * Register a listener to receive service availability-related notifications.
     * See javadoc on the {@link AvailabilityListener} class for more details.
     * <p>
     * <b>NOTE:</b> This is <b>beta</b> functionality. API and/or behaviour is subject
     * to change in future versions
     *
     * @param listener the listener impl for callbacks
     * @param executor an executor with which to execute the listener callback methods
     */
    public ThriftClientBuilder<I> withListener(AvailabilityListener listener, Executor executor) {
        checkModificationOk();
        Preconditions.checkNotNull(listener, "listener can't be null");
        Preconditions.checkNotNull(executor, "executor can't be null");
        if (listeners == null) {
            listeners = new LinkedList<>();
        }
        listeners.add(new ListenerWithExecutor(listener, executor));
        return this;
    }

    /**
     * Provide a specific {@link LoadBalancingPolicy} for this client instance to use.
     * The default policy is {@link LoadBalancingPolicy#BALANCED}. See javadoc of
     * {@link LoadBalancingPolicy} for more detail.
     * <p>
     * <b>NOTE:</b> this is "alpha" functionality and subject to change without warning
     * in future versions
     *
     * @param lbPolicy
     */
    public ThriftClientBuilder<I> withLoadBalancer(LoadBalancingPolicy lbPolicy) {
        checkModificationOk();
        Preconditions.checkNotNull(lbPolicy, "lbPolicy can't be null");
        this.lbPolicy = lbPolicy;
        return this;
    }

    // ----

    static RuntimeException asRuntimeException(Throwable t) {
        return t instanceof RuntimeException ? (RuntimeException) t : new RuntimeException(t);
    }

    private Method getMethod(String name) throws IllegalArgumentException {
        for (Method m : clientInterface.getMethods()) {
            if (m.getName().equals(name)) {
                return m;
            }
        }
        throw new IllegalArgumentException("Invalid method: " + name);
    }

    private void checkModificationOk() {
        if (locked) {
            throw new IllegalStateException("Can't modify builder once a client has been built");
        }
    }


    // ---- cache of default-configured clients ---- TBD

//	private static final LoadingCache<Class<?>,Object> proxyCache = CacheBuilder.newBuilder()
//			.build(new CacheLoader<Class<?>,Object>() {
//				@Override
//				public Object load(final Class<?> clientClass) throws Exception {
//					return ThriftClientBuilder.newBuilder(clientClass).build();
//				}
//			});
//
//	// Exception TBD
//	@SuppressWarnings("unchecked")
//	public static <I> I getClient(Class<? extends I/* & TServiceClient */> clientClass) throws Exception {
//		try {
//			return (I) proxyCache.get(clientClass);
//		} catch (ExecutionException e) {
//			throw (Exception) e.getCause();
//		}
//	}

}
